
\section{Radiointerferometrie}
\sectionauthor{Benjamin Knöbel del Olmo, Ole Fleck, Aaron Gschwendt, Mara Germann}
\subsection{Kalibrierung der Radiointerferometriedaten}
Die Aufgabe dieses Projektteils war es, Daten, die Teil A (Ref!) simuliert, zu korrigieren. Im Gegensatz zu Beobachtungen durch einzelne Antennenarrays wurde das Schwarze Loch M87 durch das Event Horizon Telescope vermessen. Das EHT besteht aus Arrays (Gruppen aus mehreren Radioantennen) in verschiedensten Ländern (Chile, Spanien, Hawaii etc.), was den Vorteil hat, dass der Durchmesser der Beobachtung  ansteigt und es den Forschern so ermöglicht, kleinere Winkel zu unterscheiden (Ref Radiointerferometrie wg Formel!).
Grundsätzlich möchten wir unsere Simulationsparameter so an die wirklichen Daten anpassen, dass der Unterschied zwischen beiden minimiert wird. Beim EHT kommt nun die Besonderheit der unterschiedlichen Wetterlagen an den verschiedenen Standorten ins Spiel.
Es ist mit heutigen Methoden nicht möglich, den Effekt der interferierenden Quellen ausreichend zu bestimmen. Zwei Effekte treten auf: Zum einen entsteht durch die Bremsung der Radiowelle eine Phasenverschiebung, zum anderen wird die Signalstärke reduziert.
Diese Störungen lassen sich durch die Formel
$$d_{abt\lambda}\rightarrow g_{at\lambda} \bar{g}{bt\lambda}d{abt\lambda} $$
darstellen, wobei $a$ und $b$ für ein betrachtetes Antennenpaar (also Antenne $a$ und Antenne $b$) steht und $\bar{g}{at\lambda}$,  $\bar{g}{bt\lambda}$ zwei für die jeweiligen Antennenstörung beschreibende komplexe Zahlen sind: Der reelle Teil spiegelt die Signalstärkenreduktion wieder, während der imaginäre Teil die Phasenverschiebung repräsentiert.
Um diese Effekte zu annullieren bestimmen wir die Closure Quantity, eine bereinigte Form der gegebenen Daten. Closure Phases behandeln die Phasenverschiebung der empfangenen Welle und Closure Amplitudes die Änderung der Signalstärke. Daher muss eine Funktion
\begin{equation}d^0_{t\lambda}=f(d_{abt\lambda}\forall a,b)\end{equation}
gefunden werden, sodass die Transformationen
\begin{align}
d_{abt\lambda} &\rightarrow e^{i \phi at} e^{-i\pi bt} d_{abt\lambda }d(0)\\
d_{abt\lambda}&\rightarrow|g_{at\lambda}||g_{bt\lambda}|d_{abt\lambda}|
\end{align}
konstant sind, das heißt dass, die Störung keine Rolle mehr spielen. In der ersten Funktion werden die Verschiebungen in der Phase rausgekürtzt, in der zweiten die Amplitudenverschiebung.
Für die Closure Phases lautet die gesuchte Funktion
\begin{equation}f(d_{a,b},d_{b,c},d_{a,c})=d_{a,b}+d_{b,c}-d_{a,c}\end{equation}
Unter der Anahme, dass $\psi_n = e^{i \phi_{n,t}}$ gilt, kann man zeigen, dass durch Einsetzen in die Funktion die Verschiebung der Daten herausgerechnet wird.
\begin{align}
f(\psi_a\bar{\psi_b} d_{a,b},\psi_b\bar{\psi_c}d_{b,c},\psi_a \bar{\psi_c} d_{a,c})&=\psi_1\bar{\psi_b}d_{a,b}+\psi_b\bar{\psi_c}d_{b,c}-\psi_a \bar{\psi_c} d_{a,c}\\
&=e^{i \phi_{a,t}-i\phi_{b,t}}d_{a,b}+e^{i \phi_{b,t}-i\phi_{c,t}}d_{b,c}-e^{i \phi_{a,t}-i\phi_{c,t}}d_{a,c}\\
&=d_{a,b}+d_{b,c}-d_{a,c}\\
&=f(d_{a,b},d_{b,c},d_{a,c})
\end{align}
Für die Closure Amplitudes lautet die gesuchte Funktion:
\begin{align}
f(d_{a, b},d_{a, c},d_{a, d},d_{b, c},d_{b, d},d_{c, d})\overset{!}{=}\frac{d_{a,b}\cdot d_{c,d}}{d_{a,c} \cdot d_{b,d}}
\hspace{3mm}\text{bzw.}\hspace{3mm} \frac{d_{a,d}\cdot d_{b,c}}{d_{a,c} \cdot d_{b,d}}
\end{align}
Die Antennenpaare werden in Dreier- bzw. Vierergruppen aufgeteilt. Mann kann , in der die Spalten alle möglichen Antennenpaare darstellen und jede Zeile für eine der linearunabhängigen Möglichkeiten die Antennenpaare zu verknüpfen, eine Null bedeutet, dass das Antennenpaar nicht verwendet wird. Bei den Closure Phases stehen die Zahlen in der Matrix für das Vorzeichen, bei den Closure Amplitudes für den Vorzeichen des Exponents. Bei $n$ Antennen gibt es $\binom{n-1}{2}= \frac{1}{2}(n-1)\cdot(n-2)$ linear unabhängige Reihen in der Matrix.
Daher hat die Closure Phase Matrix $\binom{4-1}{2}=3$ Reihen und sieht folgend aus.
\begin{equation}
\bordermatrix{
~ &a,b&a,c&a,d&b,c&b,d&c,d\cr
~&1&-1&0&1&0&0 \cr
~&1&0&-1&0&1&0 \cr
~&0&1&-1&0&0&1 \cr}
\end{equation}

Um am Ende ein Bild zu erzeugen, benötigen wir den Posterior des Bayes Theorem, welcher uns ermöglicht, fehlende Daten durch wahrscheinliche zu ersetzen. Um diesen zu berechnen, setzen wir ein:

\begin{equation}
P(\xi|d)= \frac {P(d|\xi)\cdot P(\xi)}{ P(d) }
\end{equation}
\begin{equation}
P(d|\xi)=  {P(d_{ph}|\xi)\cdot P(d_{amp}|\xi)}    
\end{equation}
Die Likelihood (1.12) besteht aus zwei Teilen: $P(d_{ph}|\xi)$, der Warscheinlichkeit der Closure Phases unter der Bedingung $\xi$ und $P(d_{am}| \xi)$, der Wahrscheinlichkeit der Closure Amplitudes unter der Bedingung $\xi$.
\begin{align}
 -\log {P(\xi|d)} &=
 \mathcal{H} (\xi|d) = \mathcal{H} (d_{ph}|\xi)+\mathcal{H} (d_{amp}|\xi)+\mathcal{H} (\xi) \\
&= \frac {1}{2}\cdot \Bigg[d_{ph} - f_{ph}(R(sky(\xi))) \Bigg]^\dagger N^{-1}_{ph} \Bigg[d_{ph} - f_{ph}(R(sky(\xi))) \Bigg]  
\\  & + \frac {1}{2}\cdot \Bigg[d_{amp} - f_{amp}(R(sky(\xi))) \Bigg]^\dagger N_{amp}^{-1}\Bigg[d_{ph} - f_{ph}(R(sky(\xi))) \Bigg]
\\ & +  \frac {1}{2} \cdot \xi^\dagger \xi
\end{align}
Der Logarithmus(1.14), also $H(\xi|d)$ muss minimiert werden, um den Posterior, die Wahrscheinlichkeit, dass die Simulation durch gewählte Parameter $\xi$ gut zu den gemessenen Daten passt, zu maximieren.
Der Parameter $\xi$ wird im Folgenden so optimiert, dass man eine durch $\xi$ definierte Normalverteilung eine möglichst kleine Differenz zu den errechneten Daten erreicht(s. Kullback-Leibler-Divergenz(hier kommt noch eine Referenz!)) % REF!!!
Schlussendlich erhält man folgendes Bild:
(Hier wird das Schwarze Loch Foto eingefügt)



\subsection{Radiointerferometrie-Response und Event-Horizon-Telescope-Daten}

Zur Rekonstruktion eines Bildes des Schwarzen Lochs M87* muss basierend auf den Daten des Event-Horizon-Telescopes zunächst eine Response-Funktion implementiert werden, um die Informationen vom Signal- in den Datenraum zu transferieren $s \mapsto d$. Mit der entsprechenden Implementierung wird sich der nachfolgende Abschnitt befassen.

Es werden Daten in Form von acht csv-Dateien verwendet, die im April 2017 aufgenommen wurden. Diese stammen von mehreren Messreihen und wurden zur weiteren Verarbeitung in Form von csv-Dateien gespeichert.
Um mit den Messwerten in Python arbeiten zu können, werden die csv-Dateien in NumPy-Arrays konvertiert. Durch das NumPy-Array werden die Daten aus den csv-Dateien auf einem zweidimensionalen Gitter abgebildet.

Zunächst müssen die Frequenzen der Radiowellen ausgelesen werden. Diese elektromagnetischen Wellen werden in unmittelbarer Nähe des Schwarzen Lochs ausgesandt. Es wurden die beiden Frequenzen $f_1 = 227,0707$ GHz und $f_2 = 229,0707$ GHz betrachtet. Darüber hinaus werden auch die Verbindungsvektoren zwischen den Antennen $uvw$ ausgelesen.

Um aus den Messwerten ein Bild erstellen zu können, wird die Anzahl der Pixel sowohl in x-, als auch in y-Richtung auf zunächst $100$ festgelegt, wobei dieser Wert variabel ist. Die Größe der Pixel ergibt sich für $\delta \theta$:
\[ \delta \theta = 1.22 \cdot \displaystyle\frac{\lambda}{D} = 1.22 \cdot \displaystyle\frac{c}{f \cdot D} \]

Da es sich bei dem Event Horizon Telescope um einen Zusammenschluss von Antennen auf der ganzen Welt handelt, ergibt sich ein Durchmesser von $D_{EHT} \approx D_{Erde} \approx 10.000km$. Desweiteren beschreibt $\lambda$ die Wellenlänge der Radiowellen und $c$ deren Ausbreitungsgeschwindigkeit, die der Lichtgeschwindigkeit entspricht. In die Formel eingesetzt erhält man:

\begin{equation}
  \delta \theta = 1.22 \cdot \displaystyle\frac{3 \cdot 10^{8} \displaystyle\frac{\text{m}}{\text{s}}} {229.0707 \text{GHz} \cdot 10.000 \text{km}} = (1,598 \cdot 10^{-10}) \mu \text{as} 
\end{equation}

Damit ein erstes Bild des Schwarzen Lochs generiert werden kann, ist es notwendig, die Daten $d$ mittels folgender Formel zu beschreiben. Die Werte für $I_{Amplitude}$ und $I_{Phase}$ sind in den csv-Dateien gegeben:
\[ d = I_{Amplitude} \cdot e^{i \cdot I_{Phase}} \]

Aufgrund unvollständiger Informationen, die durch die Distanz der Antennen des Event-Horizon-Telescopes entstehen, muss zur Bilderstellung Bayes'sche Statistik angewandt werden. Im Gegensatz zu NumPy stellt NIFTy entsprechende Funktionen bereit, die dies ermöglichen. Um vom Signalraum $I$ (Signal des betrachteten Objekts) in den Datenraum $d$ (empfangene Daten) zu gelangen, nutzt man in NIFTy die Funktion \verb|dirty2vis| aus der Python-Bibliothek \verb|ducc0|. Diese ist vergleichbar mit der Response $R$ beim Wiener Filter. $R^{\dagger}$ entspricht der adjungierten Abbildung \verb|vis2dirty|, die es ermöglicht, aus dem bekannten Datenraum auf den Signalraum zu schließen.

Um diese Funktionen in NIFTy wiederholt anwenden zu können, werden sie in eine Klasse verpackt. Es handelt sich dabei um eine Klasse, die von \verb|ift.LinearOperator| - einem NIFTy-Operator - erbt. Dazu müssen unter Anderem \verb|domain| und \verb|target| initialisiert werden. Der Signalraum wird über \verb|domain| beschrieben, der Datenraum über \verb|target|. In der Klasse werden die Funktionen \verb|dirty2vis| und \verb|vis2dirty| durch die Methoden \verb|TIMES| und \verb|ADJOINT_TIMES| ersetzt.
